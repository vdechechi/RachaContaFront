/*!
 * devextreme-vue
 * Version: 24.1.4
 * Build date: Mon Jul 15 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */

import { h, } from 'vue';
import { configurationDefaultTemplate, configurationTemplate, declaredTemplates, getChildren, getConfigurationOptions, mount, } from './vue-helper';
const TEMPLATE_PROP = 'template';
function asConfigurable(component) {
    const componentOptions = component;
    if (!componentOptions) {
        return;
    }
    if (!componentOptions.$_config || !componentOptions.$_config.name) {
        return undefined;
    }
    return componentOptions;
}
function hasTemplate(component) {
    return TEMPLATE_PROP in component.type.props && configurationTemplate(component);
}
function discover(component) {
    const templates = {};
    const namedTeplates = declaredTemplates(component);
    for (const slotName in namedTeplates) {
        if (slotName === 'default' && component.$slots.default) {
            continue;
        }
        const slot = namedTeplates[slotName];
        if (!slot) {
            continue;
        }
        templates[slotName] = slot;
    }
    const componentChildren = getChildren(component);
    for (const childComponent of componentChildren) {
        const configurable = asConfigurable(childComponent);
        if (!configurable) {
            continue;
        }
        const defaultSlot = configurationDefaultTemplate(childComponent);
        if (!defaultSlot || !hasTemplate(childComponent)) {
            continue;
        }
        const templateName = `${configurable.$_config.fullPath}.${TEMPLATE_PROP}`;
        templates[templateName] = defaultSlot;
    }
    return templates;
}
function clearConfiguration(content) {
    const newContent = [];
    content.forEach((item) => {
        const configurable = getConfigurationOptions(item);
        if (!configurable || !configurable.$_optionName) {
            newContent.push(item);
        }
    });
    return newContent;
}
function mountTemplate(getSlot, parent, data, name, placeholder) {
    return mount({
        name,
        inject: ['eventBus'],
        created() {
            this.eventBus.add(this.$_updatedHandler);
        },
        mounted() {
            data.onRendered();
        },
        unmounted() {
            this.eventBus.remove(this.$_updatedHandler);
        },
        methods: {
            $_updatedHandler() {
                this.$forceUpdate();
            },
        },
        render: () => {
            const content = clearConfiguration(getSlot()(data));
            if (!content) {
                return h('div');
            }
            return content.length > 1 ? content : content[0];
        },
    }, parent, placeholder);
}
export { mountTemplate, discover, };
