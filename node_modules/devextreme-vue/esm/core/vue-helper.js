/*!
 * devextreme-vue
 * Version: 24.1.4
 * Build date: Mon Jul 15 2024
 *
 * Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file in the root of the project for details.
 *
 * https://github.com/DevExpress/devextreme-vue
 */

import { Comment, createApp, } from 'vue';
import { camelize } from './helpers';
import { isFragment } from './children-processing';
export const VMODEL_NAME = 'modelValue';
export function getChildren(component) {
    if (!hasChildren(component) || !component.$_config) {
        return [];
    }
    const children = component.$.subTree && component.$.subTree.children;
    if (!Array.isArray(children)) {
        return [];
    }
    // @ts-expect-error TS7030
    return children.filter((child) => {
        if (!isFragment(child)) {
            return child;
        }
    });
}
export function getComponentInfo(component) {
    return getConfigurationOptions(component);
}
export function getNormalizedProps(props) {
    const result = {};
    for (const propName in props) {
        if (props.hasOwnProperty(propName)) {
            result[camelize(propName)] = props[propName];
        }
    }
    return result;
}
export function configurationChildren(component) {
    if (!component.children || !component.children.default) {
        return [];
    }
    return findConfigurationComponents(component.children.default());
}
export function configurationDefaultTemplate(node) {
    if (!node.children || node.children === 'object' || !node.children.default) {
        return;
    }
    return hasInlineTemplate(node.children.default()) ? node.children.default : undefined;
}
export function configurationTemplate(node) {
    return configurationDefaultTemplate(node);
}
export function declaredTemplates(component) {
    return component.$slots;
}
export function defaultSlots(component) {
    const templates = declaredTemplates(component);
    if (!templates.default) {
        return [];
    }
    return templates.default();
}
export function mount(options, parent, el) {
    const template = createApp(options);
    template.provide('eventBus', parent.eventBus);
    setAppContext(template, parent);
    return template.mount(el);
}
export function getComponentProps(component) {
    const props = component.$.vnode.props || {};
    return getNormalizedProps(props);
}
export function usedConfigurationProps(node) {
    return node.props;
}
export function getNodeOptions(component) {
    if (component.$) {
        return component.$.vnode;
    }
    return component;
}
export function getNodeTypeOfComponent(component) {
    return component.$.vnode.type;
}
export function getVModelValue(options) {
    return options[VMODEL_NAME];
}
export function setCompatOptions(component) {
    component.compatConfig = {
        MODE: 3,
    };
}
export function setVModel(config) {
    const eventName = `update:${VMODEL_NAME}`;
    config.model.prop = VMODEL_NAME;
    config.model.event = eventName;
    config.props.modelValue = {};
    config.emits = { ...config.emits, [`${eventName}`]: null };
}
function setCustomPluginsData(appContext, parentAppContext) {
    for (const prop in parentAppContext) {
        if (!appContext.hasOwnProperty(prop) && parentAppContext.hasOwnProperty(prop)) {
            appContext[prop] = parentAppContext[prop];
        }
    }
}
function setAppContext(template, parent) {
    template._context.components = Object.assign(parent.$.appContext.components, template._context.components);
    Object.setPrototypeOf(template._context.provides, Object.getPrototypeOf(parent.$.provides));
    Object.assign(template._context.provides, parent.$.appContext.provides);
    template._context.config = parent.$.appContext.config;
    template._context.directives = parent.$.appContext.directives;
    template._context.mixins = parent.$.appContext.mixins;
    setCustomPluginsData(template._context.app, parent.$.appContext.app);
}
function findConfigurationComponents(children) {
    return children.filter((child) => {
        if (isFragment(child)) {
            return findConfigurationComponents(child.children || []);
        }
        const childType = child.type;
        if (childType && typeof childType === 'object' && childType.$_optionName) {
            delete child.$_config;
            delete child.$_innerChanges;
            return child;
        }
    });
}
function hasInlineTemplate(children) {
    let hasTemplate = false;
    children.forEach((child) => {
        if (!isConfiguration(child) && !isFragment(child) && !isComment(child)) {
            hasTemplate = true;
        }
    });
    return hasTemplate;
}
function isComment(node) {
    return node.type === Comment || (node.type.toString() === 'Symbol()' && !node.children);
}
function isConfiguration(child) {
    return child.type && typeof child.type === 'object' && child.type.$_optionName;
}
export function getConfigurationOptions(node) {
    return node.type;
}
function hasChildren(component) {
    return component.$.vnode && component.$.vnode.children && component.$.vnode.children.default;
}
